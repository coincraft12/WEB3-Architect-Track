# 11강. 스마트컨트랙트 계정 정의: “코드 계정”과 상태 변화(State Transition)의 본질

## 0) 이 강의의 한 문장
**스마트컨트랙트는 ‘프로그램’이 아니라, 블록체인 위에서 주소를 가진 ‘코드 계정’이며, 트랜잭션에 의해 호출될 때만 실행되어 상태를 바꾼다.**  
즉, 스마트컨트랙트는 “자동으로 움직이는 로봇”이 아니라 **규칙이 저장된 상태 머신(State Machine)** 이다.

---

## 1) 강의 목표 (수강생이 끝나고 할 수 있어야 하는 것)
이 강의를 마치면 수강생은:

1. 스마트컨트랙트를 “자동 실행 프로그램”이 아니라 **주소를 가진 코드 계정**으로 정의할 수 있다.  
2. EOA(외부 소유 계정)와 컨트랙트 계정의 차이를 “키 vs 코드” 관점으로 설명할 수 있다.  
3. 컨트랙트의 핵심 구성요소(코드/스토리지/이벤트/상태 전이)를 구조적으로 설명할 수 있다.  
4. 컨트랙트 호출이 어떻게 “상태 변화”를 만들고, 왜 가스가 필수인지 연결해 설명할 수 있다.  
5. 다음 모듈(B4 미니 케이스)로 연결: 구조 읽기의 대상이 “사람 주소”뿐 아니라 “규칙 주소(컨트랙트)”라는 점을 이해한다.

---

## 3) 핵심 정의: 컨트랙트 계정 = (주소) + (코드) + (상태)
### 3.1 주소(Address)
- 컨트랙트도 주소가 있다(EOA와 동일한 “좌표” 형태)
- 그래서 To에 컨트랙트 주소가 들어가면 “코드 실행 요청”이 된다

### 3.2 코드(Code)
- 컨트랙트의 규칙(로직)이 저장된 영역
- 핵심: **코드는 배포 후 바뀌기 어렵다(일반적으로)**  
  - 그래서 배포 전 설계/검증이 중요  
  - (업그레이드 패턴은 Advanced에서)

### 3.3 상태(State / Storage)
- 컨트랙트가 기억하는 데이터(잔액, 소유자, 매핑, 변수 등)
- 컨트랙트의 진짜 힘은 “코드”보다 **상태를 바꾸는 규칙**에 있다

**암기 문장**
- “컨트랙트는 코드가 아니라, 상태를 바꾸는 규칙을 가진 계정이다.”

---

## 4) EOA vs 컨트랙트 계정(초급에서 반드시 정리)
### 4.1 EOA(Externally Owned Account)
- 통제권: 개인키(서명)
- 실행: 스스로 실행하지 못함(코드 없음)
- 역할: 트랜잭션을 “시작”하는 주체(행동의 발화점)

### 4.2 컨트랙트 계정(Contract Account)
- 통제권: 코드(규칙)
- 실행: 호출될 때만 실행
- 역할: 규칙에 따라 상태를 바꾸는 “행동의 엔진”

**한 문장 요약**
- EOA는 “서명하는 손”, 컨트랙트는 “규칙을 집행하는 기계”다.

---

## 5) “자동 실행” 오해 깨기: 컨트랙트는 왜 ‘자동’이 아닌가?
블록체인은 기본적으로 “이벤트 루프”가 없다.
- 서버처럼 백그라운드에서 돌아가는 프로세스가 없음
- 컨트랙트는 “가만히 있다가” 호출되면 실행됨

그럼 자동처럼 보이는 건 무엇인가?
- 누군가(사용자/봇/keeper)가 주기적으로 호출해주는 구조
- 또는 프로토콜 참여자들이 인센티브로 호출을 유도하는 구조

**설계자 포인트**
- “자동”은 코드 속성이 아니라 **생태계 설계(인센티브/운영)** 결과다.

---

## 6) 상태 전이(State Transition): WEB3의 본질
스마트컨트랙트의 핵심은 다음 3단계로 정리된다.

1) 입력(Input): 트랜잭션 data(함수 + 인자)  
2) 검증(Checks): require / 권한 / 조건 확인  
3) 전이(Effects): 스토리지 변경, 잔액 이동, 이벤트 기록

이게 곧 “규칙 기반 상태 머신”이다.

**암기 문장**
- 입력이 들어오면, 규칙이 검사하고, 통과하면 상태가 바뀐다.

---

## 7) 이벤트(Event/Logs)의 위치: “상태”가 아니라 “설명/신호”
초급에서 많이 헷갈리는 부분:
- 이벤트를 “데이터 저장”으로 착각

정리:
- 상태(storage)는 컨트랙트가 기억하는 현실
- 이벤트(log)는 외부가 읽기 쉬운 신호/설명(인덱싱용)
- 많은 분석/대시보드는 이벤트를 기반으로 만든다(편리하니까)

**설계자 포인트**
- 이벤트는 “진실”이 아니라 “보고서”에 가깝다.  
  진실은 상태다.

---

## 8) 가스와 스마트컨트랙트의 연결(10강 복습 연결)
왜 컨트랙트 실행에 가스가 중요하냐면:
- 코드 실행은 자원을 소비하고(연산, 스토리지)
- 그 자원 소비에 상한과 비용을 걸어야 DoS를 막는다
- 복잡한 함수/루프/스토리지 쓰기는 가스를 급격히 늘린다

**초급 결론**
- 컨트랙트 설계는 “기능 설계”이자 “가스/자원 설계”다.

---

## 9) 컨트랙트를 “규칙”으로 읽는 5요소 프레임(구조 설계자 도구)
컨트랙트 호출을 볼 때, 아래 질문으로 해석한다.

1) 목적(Goal): 이 컨트랙트는 무엇을 규정하는가? (교환? 대출? 발행?)  
2) 권한(Authority): 누가 무엇을 할 수 있나? (owner/role/anyone)  
3) 입력(Input): 어떤 함수와 어떤 인자를 받나?  
4) 상태(State): 무엇을 저장하고 어떤 조건에서 바뀌나?  
5) 출력(Output): 어떤 이벤트를 남기고 어떤 자산 이동이 일어나나?

---

## 10) 미니 케이스(강의 중 10~15분)
### 케이스: “토큰 전송이 왜 컨트랙트 호출이지?”
많은 토큰은 네이티브 코인(예: ETH)처럼 단순 잔액 이동이 아니다.
- 토큰은 컨트랙트가 소유권 맵핑을 관리한다
- transfer는 컨트랙트의 함수를 호출해 상태를 바꾸는 행위다

즉,
- ETH 전송: 프로토콜 레벨의 상태 변화
- 토큰 전송: 컨트랙트 규칙에 따른 상태 변화

**핵심 메시지**
- WEB3에서 “자산”도 규칙(컨트랙트)이 정의한다.

---

## 12) 과제
### 과제 1: EOA vs Contract 계정 비교(1페이지)
- 통제권(키 vs 코드)  
- 실행 방식(서명/호출)  
- 실패 유형(서명/검증 vs revert)  
- 사용자 리스크(피싱/승인/권한)  
- 온체인 분석 포인트(무엇을 보면 역할이 드러나는가)

### 과제 2(선택): “자동”이라는 말을 구조적으로 고치기(10문장)
- “자동으로 수익을 준다” 같은 문장을  
  - 호출자/인센티브/조건/리스크를 포함한 구조 문장으로 바꿔쓰기

---

## 15) (집필 확장용) 이 강의를 책으로 옮기면 이렇게 된다
- 1. 스마트컨트랙트는 프로그램이 아니다: 코드 계정이다  
- 2. EOA vs 컨트랙트 계정(키 vs 코드)  
- 3. 컨트랙트의 3요소: 주소/코드/상태  
- 4. 자동 실행 오해와 호출 구조  
- 5. 상태 전이: 입력-검증-효과  
- 6. 이벤트와 상태의 구분(분석 관점)  
- 7. 가스: 규칙 실행의 자원 모델  
- 8. 실습: 컨트랙트 규칙 카드 만들기

