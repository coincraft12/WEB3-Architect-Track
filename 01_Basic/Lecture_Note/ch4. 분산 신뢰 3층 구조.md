# 4강. 분산 신뢰 3층 구조: 합의(Consensus)·실행(Execution)·검증(Validation)

## 0) 이 강의의 한 문장
**분산 신뢰는 “한 기관을 믿는 것”이 아니라, ‘규칙(실행)·확인(검증)·기록 합의(합의)’ 3층 구조로 신뢰를 쪼개서 네트워크에 분산시키는 방식이다.**

---

## 1) 강의 목표 (수강생이 끝나고 할 수 있어야 하는 것)
이 강의를 마치면 수강생은:

1. 분산 신뢰를 **3층(합의·실행·검증)** 으로 분해해 설명할 수 있다.
2. 트랜잭션이 “기록”이 되기까지의 과정을 단계별로 말하고, 각 단계가 어느 층에 속하는지 구분할 수 있다.
3. 흔한 혼동(“합의=검증”, “검증=채굴”, “노드=검증자”)을 정리하고 용어를 정확히 쓴다.
4. 장애/사고를 봤을 때 “이건 합의 문제인지, 실행 문제인지, 검증 문제인지” 1차 진단할 수 있다.
5. 다음 강의(키 기반 소유권)로 연결되는 질문: “그럼 개인이 맡는 신뢰(키/서명)는 이 3층 중 어디에 걸리는가?”를 답할 수 있다.

---

## 2) 도입 멘트 (강의 시작 2~3분 대본)
> 1~3강에서 우리는 중앙화 구조가 왜 편하지만 위험해지는지 봤어요.  
> 기록이 하나면 빠르지만, 검열·변조·단일 장애점이 따라오고,  
> 권한이 집중되면 권한-책임 불일치가 터진다는 것도 봤죠.  
>  
> 이제 질문은 하나입니다.  
> **“그럼 기록을 여러 주체가 공유하면, 신뢰를 어떻게 만들지?”**  
>  
> 오늘은 분산 신뢰를 기술로 설명하지 않고, 구조로 설명합니다.  
> **합의·실행·검증 3층**으로 분해해서요.

---

## 3) 큰 그림: 분산 신뢰는 “신뢰 패키지”를 ‘분해’해서 네트워크에 재배치한다
중앙화 신뢰가 한 기관에 묶여 있던 것(계정/장부/결제/분쟁조정)을,
분산 시스템은 이렇게 쪼갠다.

- **실행(Execution)**: “규칙대로 상태가 바뀐다” (상태 전이 엔진)
- **검증(Validation)**: “그 실행이 규칙에 맞는지 확인한다” (로컬 확인)
- **합의(Consensus)**: “어떤 기록이 공식 역사인지 하나로 맞춘다” (글로벌 합의)

핵심 문장:
- **검증은 로컬에서 ‘맞다/틀리다’를 판단하는 일이고,**
- **합의는 네트워크 전체가 ‘무엇을 공식 기록으로 채택할지’를 맞추는 일이다.**
- 실행은 그 둘이 의존하는 “규칙 그 자체(상태 전이 함수)”다.

---

## 4) 3층 구조의 정의 (정확한 버전)

### A. 실행(Execution): “무엇이 일어나는가” — 상태 전이 규칙
실행은 매우 간단히 말하면 이거다.

- 입력: (이전 상태 + 트랜잭션)
- 출력: (새 상태 + 영수증/로그)

즉, 실행은 “장부를 어떻게 업데이트할지”를 정하는 엔진이다.

실행이 다루는 대표 요소:
- 잔액 감소/증가
- nonce 증가(재사용 방지)
- 스마트컨트랙트 코드 실행(EVM 등)
- 상태 변경(storage update)
- 이벤트 로그(event/log) 생성
- 실패(revert) 처리

**설계자 관점 포인트**
- 실행은 “돈이 움직이는 규칙”이기 때문에, 가장 핵심적인 레이어다.
- 실행이 바뀌면(업그레이드/하드포크) 시스템의 ‘현실’이 바뀐다.

---

### B. 검증(Validation): “그게 규칙대로 맞는가” — 로컬 확인
검증은 “누군가가 주장하는 기록(블록/트랜잭션)이 규칙에 맞는지” 확인하는 일이다.

검증이 다루는 대표 체크:
- 트랜잭션 서명(signature) 유효성
- nonce/잔액/가스 조건 충족 여부
- 실행 결과가 규칙과 일치하는지(상태 전이가 올바른지)
- 블록 구조가 규격에 맞는지(헤더/머클루트 등)
- (PoS 기준) 블록 제안자/투표(서명) 등이 유효한지

핵심 문장:
- **검증은 “믿지 않고 확인한다(Don’t trust, verify)”를 가능하게 만드는 층이다.**
- 그리고 검증은 가능하면 “누구나” 할 수 있어야 분산 신뢰가 강해진다.

---

### C. 합의(Consensus): “어느 기록이 공식인가” — 정렬과 최종성
합의는 “여러 후보 기록 중 무엇을 정본(정식 역사)으로 채택할지”를 결정한다.

합의가 다루는 대표 문제:
- 거래의 순서(ordering): 같은 시간에 들어온 요청을 어떤 순서로 기록할까?
- 블록 선택(fork choice): 서로 다른 블록이 생겼을 때 어떤 체인을 따라갈까?
- 최종성(finality): 어느 시점부터는 뒤집히지 않는다고 말할 수 있을까?
- 참여자 규율(incentives): 정직하게 행동하도록 보상/벌점(슬래싱 등)을 어떻게 줄까?

핵심 문장:
- **합의는 “하나의 장부”를 만드는 기술이 아니라, “하나의 역사”를 만드는 규칙이다.**

---

## 5) 가장 흔한 오해 정리 (초급에서 반드시 잡아야 함)

1) “합의 = 검증”이 아니다  
- 검증: 이 블록이 규칙에 맞냐? (로컬 판단)  
- 합의: 여러 블록 중 뭘 채택하냐? (글로벌 선택)

2) “노드 = 검증자”가 아니다  
- 노드(node): 네트워크에 연결되어 데이터를 주고받고, 상태를 유지/검증할 수 있는 참여자(소프트웨어/컴퓨터)  
- 검증자(validator): 합의 과정에서 제안/투표/서명 역할을 맡는 참여자(합의 프로토콜 역할)

3) “실행은 항상 성공”이 아니다  
- 실행 결과가 revert면 상태는 원복되지만(일반적으로), 트랜잭션 수수료/가스 사용은 발생할 수 있다.
- 즉 “실패도 기록”이다(단, 어떤 정보가 남는지는 체인/구조에 따라 다름).

---

## 6) 트랜잭션이 기록되기까지: 8단계 라이프사이클(구조로 외우기)
아래는 “사용자 → 기록”의 전형적인 흐름이다(체인마다 디테일은 다를 수 있지만 구조는 유사).

1) 사용자가 트랜잭션 생성(지갑에서)  
- 관련 층: (다음 강의의 핵심) 키/서명 준비

2) 서명(Sign) 후 네트워크로 전파  
- 관련 층: 검증(서명 유효성)으로 넘어갈 준비

3) 노드가 트랜잭션 기본 검증(형식/서명/nonce 등)  
- 관련 층: 검증

4) 대기열(메모리풀 등)에 모임  
- 관련 층: 합의(무엇을 먼저 넣을지)로 이어짐

5) 블록 제안/생성(누군가가 후보 블록을 만든다)  
- 관련 층: 합의

6) 후보 블록의 실행/검증(다른 참여자들이 확인)  
- 관련 층: 실행 + 검증

7) 체인에 채택(블록이 “정본 역사”로 편입)  
- 관련 층: 합의

8) 시간이 지나 최종성/확률적 확정이 강화됨  
- 관련 층: 합의

**암기용 한 줄**
- “실행은 바꾸는 것, 검증은 확인하는 것, 합의는 채택하는 것.”

---

## 7) 레이어별 실패/사고가 어떻게 보이는가(진단 프레임)
사고를 봤을 때, 아래처럼 1차 분류만 해도 분석이 쉬워진다.

### 7.1 합의(Consensus) 문제의 전형적 증상
- 체인이 갈라졌다(fork), 재정렬(reorg)이 발생했다
- 최종성이 늦다, 블록 생성이 불안정하다
- 특정 거래가 유독 늦게 들어간다(검열/우선순위 문제)
- 네트워크가 “어느 기록이 정본인지” 혼란을 겪는다

### 7.2 실행(Execution) 문제의 전형적 증상
- 특정 트랜잭션/컨트랙트가 예상과 다르게 동작한다
- 가스/상태 전이 관련 오류가 발생한다
- 클라이언트(실행 엔진) 간 결과가 달라진다(치명적)

### 7.3 검증(Validation) 문제의 전형적 증상
- “유효하지 않은 블록/트랜잭션”이 거부된다
- 서명/규칙 위반이 발견된다
- (PoS) 규칙 위반 시 벌점/슬래싱 이슈가 나타난다

---

## 8) 칠판/슬라이드 구성(추천)
### 슬라이드 1: 3층 박스 도식
- [Execution] 규칙대로 상태 변경  
- [Validation] 규칙 준수 확인  
- [Consensus] 어떤 기록을 채택할지 결정

### 슬라이드 2: “검증(로컬) vs 합의(글로벌)” 대비표
- 검증: 맞/틀  
- 합의: 채택/폐기

### 슬라이드 3: 트랜잭션 8단계 흐름도 + 각 단계에 레이어 라벨 붙이기

---

## 9) 미니 케이스(강의 중 10분)
### 케이스: “내 트랜잭션이 늦게 처리된다”
상황:
- 트랜잭션은 전송했는데 오랫동안 반영이 안 된다.

구조적 질문(레이어별로):
- (검증) 서명/nonce/잔액/가스 조건이 맞나? 기본 규칙 위반은 아닌가?  
- (합의) 네트워크가 바쁜가? 수수료/우선순위 정책 때문에 뒤로 밀렸나?  
- (합의) 특정 상황에서 검열/필터링이 발생할 여지가 있나?  
- (실행) 만약 포함되더라도 revert 날 가능성은 없는가?

강의 포인트:
- “느리다”는 감정 대신, **어느 레이어의 문제인지**로 재해석하는 습관을 만든다.

---

## 10) 미니 실습(15분) — 블록 익스플로러로 3층 흔적 찾기
### 실습 주제: “트랜잭션 하나를 잡고, 3층 관점으로 읽기”
(특정 체인/도구를 고정하지 않고, 어떤 익스플로러든 적용 가능하게 설계)

1) 트랜잭션 기본 정보 확인
- 성공/실패(revert) 여부 → 실행 결과
- gas used / fee → 실행 제약
- nonce → 재전송 방지(검증 요소)
- from/to/value/data → 실행 입력

2) 포함된 블록 정보 확인
- block number / timestamp → 합의 결과(어느 블록에 실렸나)
- confirmations → 합의 안정도(시간이 지날수록 뒤집힘 가능성 감소)
- (가능하면) reorg 흔적/대체 블록 여부 확인 → 합의 이슈

3) 로그(event) 확인(가능한 경우)
- 이벤트는 “실행이 남긴 구조적 흔적”이다.

**출력(산출물)**: “3층 읽기 메모 1장”
- Execution: 무슨 상태 변화가 있었나? 성공/실패? 로그는?  
- Validation: 어떤 규칙(서명/nonce/가스)이 핵심이었나?  
- Consensus: 언제/어느 블록에 포함됐나? 확정감은 어느 정도인가?

---

## 11) 과제
### 과제 1: 3층 분해 리포트(1페이지)
- 사례 2개를 고른다(아래 중 택2)
  - 트랜잭션 지연
  - revert(실패) 트랜잭션
  - 네트워크 혼잡(수수료 급등)
  - 체인 재정렬(reorg) 관련 뉴스/사건
- 각 사례에 대해:
  - 어느 레이어 문제인지 1차 분류  
  - 왜 그렇게 판단했는지 근거 2개  
  - 사용자/서비스 관점에서 대응책 1개

### 과제 2(선택): “3층 관점으로 설명 문장 만들기”
- “블록체인이 신뢰를 만든다”를  
  합의/실행/검증 각각 1문장으로 설명해보기

---

## 12) 강의 마무리 30초 대본
> 오늘은 분산 신뢰를 ‘기술 단어’로 외우지 않고, 구조로 분해했습니다.  
> 실행은 상태를 바꾸는 규칙, 검증은 규칙 준수 확인, 합의는 공식 기록 채택입니다.  
>  
> 다음 강의에서는, 이 구조 안에서 “개인에게 내려오는 신뢰” —  
> **키와 서명(소유권)** 이 정확히 무엇을 의미하는지 들어가겠습니다.

---

## 13) 퀴즈(10문항, 복습용)
1) 실행(Execution)을 한 문장으로 정의하라.  
2) 검증(Validation)을 한 문장으로 정의하라.  
3) 합의(Consensus)를 한 문장으로 정의하라.  
4) “검증은 로컬, 합의는 글로벌”의 의미는?  
5) “노드”와 “검증자(validator)”는 어떻게 다른가?  
6) 트랜잭션이 기록되기까지 8단계 중, 합의가 핵심인 단계 2개를 고르라.  
7) revert는 어느 레이어의 결과로 이해하는가?  
8) confirmations는 주로 어느 레이어의 안정도를 나타내는가?  
9) 체인 재정렬(reorg)은 주로 어느 레이어 문제인가?  
10) 왜 분산 신뢰에서 “누구나 검증 가능”이 중요하다고 했는가?

---

## 14) (집필 확장용) 이 강의를 책으로 옮기면 이렇게 된다
- 1. 신뢰를 분해하라: 합의·실행·검증  
- 2. 실행: 상태 전이 규칙이 세계를 만든다  
- 3. 검증: 믿지 않고 확인하는 구조  
- 4. 합의: 하나의 역사를 선택하는 규칙  
- 5. 트랜잭션 라이프사이클 8단계(도식)  
- 6. 레이어별 장애/사고 진단 프레임  
- 7. 실습: 익스플로러로 3층 흔적 읽기  
- 8. 다음 장 예고: 키 기반 소유권 구조(서명은 무엇을 증명하는가)
